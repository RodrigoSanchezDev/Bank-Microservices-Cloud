# Bank Microservices Cloud

> Sistema bancario distribuido de alto rendimiento construido con arquitectura de microservicios

[![Spring Boot](https://img.shields.io/badge/Spring%20Boot-3.5.0-brightgreen.svg)](https://spring.io/projects/spring-boot)
[![Spring Cloud](https://img.shields.io/badge/Spring%20Cloud-2024.0.0-blue.svg)](https://spring.io/projects/spring-cloud)
[![Java](https://img.shields.io/badge/Java-21-orange.svg)](https://openjdk.org/)
[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)
[![Docker](https://img.shields.io/badge/Docker-Ready-blue.svg)](https://www.docker.com/)
[![Resilience4j](https://img.shields.io/badge/Resilience4j-2.x-green.svg)](https://resilience4j.readme.io/)

---

## ‚ùì Preguntas Frecuentes (FAQ)

<details>
<summary><strong>¬øPor qu√© usar microservicios en lugar de un monolito?</strong></summary>

**Ventajas**:

- **Escalabilidad independiente**: Escala solo los servicios que lo necesitan
- **Despliegue independiente**: Actualiza sin afectar todo el sistema
- **Tecnolog√≠a heterog√©nea**: Usa el stack m√°s adecuado para cada servicio
- **Resiliencia**: Fallas aisladas, no colapsa todo el sistema
- **Equipos aut√≥nomos**: Desarrollo y despliegue descentralizado

**Desventajas**:

- Mayor complejidad operacional
- Necesidad de herramientas de orquestaci√≥n (Docker, Kubernetes)
- Debugging distribuido m√°s complejo

</details>

<details>
<summary><strong>¬øC√≥mo funciona el Circuit Breaker?</strong></summary>

El **Circuit Breaker** monitorea las peticiones a servicios externos:

1. **CLOSED** (Estado Normal):

   - Todas las peticiones pasan normalmente
   - Registra √©xitos y fallos

2. **OPEN** (Servicio Ca√≠do):

   - Se alcanza el umbral de fallos (50% en 10 peticiones)
   - Peticiones fallan inmediatamente sin llamar al servicio
   - Espera 10 segundos antes de intentar recuperaci√≥n

3. **HALF_OPEN** (Prueba de Recuperaci√≥n):
   - Permite 3 peticiones de prueba
   - Si tienen √©xito ‚Üí CLOSED
   - Si fallan ‚Üí OPEN

**Beneficio**: Evita sobrecargar servicios ca√≠dos y falla r√°pidamente

</details>

<details>
<summary><strong>¬øEs necesario usar Docker?</strong></summary>

**No es obligatorio**, pero es altamente recomendado:

**Sin Docker**:

```bash
# Iniciar cada servicio manualmente
cd config-server && mvn spring-boot:run
cd eureka-server && mvn spring-boot:run
cd account-service && mvn spring-boot:run
```

**Con Docker**:

```bash
# Un solo comando
docker-compose up -d
```

**Ventajas de Docker**:

- Entorno consistente (desarrollo = producci√≥n)
- Networking autom√°tico entre servicios
- Gesti√≥n de dependencias (PostgreSQL, Redis)
- Escalabilidad horizontal simple

</details>

<details>
<summary><strong>¬øC√≥mo agrego un nuevo microservicio?</strong></summary>

**Paso 1**: Crear el m√≥dulo Maven

```bash
cd bank-microservices-cloud
mkdir customer-service
cd customer-service
# Copiar estructura de account-service
```

**Paso 2**: Configurar `pom.xml`

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-config</artifactId>
    </dependency>
</dependencies>
```

**Paso 3**: Crear configuraci√≥n en Config Server

```yaml
# config-server/src/main/resources/config-repo/customer-service.yml
spring:
  application:
    name: customer-service
server:
  port: 8082
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
```

**Paso 4**: Registrar en Eureka

```java
@SpringBootApplication
@EnableDiscoveryClient
public class CustomerServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(CustomerServiceApplication.class, args);
    }
}
```

**Paso 5**: Agregar a Docker Compose

```yaml
customer-service:
  build: ./customer-service
  ports:
    - "8082:8082"
  depends_on:
    - config-server
    - eureka-server
```

</details>

<details>
<summary><strong>¬øC√≥mo funciona el API Gateway BFF con HTTPS y JWT?</strong></summary>

**Arquitectura del Gateway**:

El **API Gateway BFF** (Backend For Frontend) centraliza todas las peticiones usando **Spring Cloud Gateway Reactive**:

- **Puerto HTTPS**: 8443 (certificado SSL auto-firmado)
- **Autenticaci√≥n**: JWT centralizada mediante `GlobalFilter` (sin Spring Security)
- **Enrutamiento**: Basado en paths con Service Discovery v√≠a Eureka
- **Resiliencia**: Circuit Breaker integrado en cada ruta

**Flujo de Autenticaci√≥n**:

1. **Login** (endpoint p√∫blico):

   ```bash
   curl -k -X POST https://localhost:8443/api/auth/login \
     -H "Content-Type: application/json" \
     -d '{"username": "admin", "password": "admin123"}'
   ```

2. **Respuesta con Token**:

   ```json
   {
     "token": "eyJhbGciOiJIUzI1NiJ9...",
     "username": "admin"
   }
   ```

3. **Uso del Token**:
   ```bash
   curl -k -X GET https://localhost:8443/api/customers \
     -H "Authorization: Bearer {token}"
   ```

**Componentes del Gateway**:

- **`JwtAuthenticationFilter`** (GlobalFilter con orden -100):

  - Valida tokens JWT en cada petici√≥n
  - Rechaza con 401 si el token es inv√°lido
  - Agrega header `X-User-Id` con el username extra√≠do
  - Rutas p√∫blicas: `/api/auth/login`, `/actuator/health`, `/swagger-ui`

- **`JwtTokenUtil`**:

  - Genera tokens con expiraci√≥n de 24 horas
  - Valida firma y expiraci√≥n
  - Extrae claims (username, roles)
  - Secret key: `YourSuperSecretKeyForJWTTokenGeneration123456789`

- **`AuthController`**:
  - Login con usuarios hardcodeados:
    - `admin` / `admin123` (roles: ADMIN, USER)
    - `user` / `user123` (rol: USER)

**Configuraci√≥n de Rutas**:

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: account-service-route
          uri: lb://account-service
          predicates:
            - Path=/api/accounts/**
          filters:
            - name: CircuitBreaker
              args:
                name: accountServiceCircuitBreaker
                fallbackUri: forward:/fallback

        - id: customer-service-route
          uri: lb://customer-service
          predicates:
            - Path=/api/customers/**

        - id: transaction-service-route
          uri: lb://transaction-service
          predicates:
            - Path=/api/transactions/**
```

**Certificado SSL**:

- Keystore: `classpath:keystore/bank-bff.p12`
- Password: `bankbff123`
- Alias: `bank-bff`
- Tipo: PKCS12

**Ventajas**:

- ‚úÖ Punto √∫nico de entrada (Single Entry Point)
- ‚úÖ Autenticaci√≥n centralizada (un solo lugar para JWT)
- ‚úÖ HTTPS/TLS para todas las comunicaciones externas
- ‚úÖ Service Discovery autom√°tico con Eureka
- ‚úÖ Circuit Breaker para resiliencia
- ‚úÖ Microservicios sin l√≥gica de autenticaci√≥n (confianza en BFF)

</details>

<details>
<summary><strong>¬øC√≥mo funciona la autenticaci√≥n JWT?</strong></summary>

**Flujo de Autenticaci√≥n**:

1. **Login**:

   ```bash
   POST /api/auth/login
   Body: { "username": "user1", "password": "password123" }
   ```

2. **Respuesta con Token**:

   ```json
   {
     "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
     "expiresAt": "2024-12-31T23:59:59Z"
   }
   ```

3. **Uso del Token**:
   ```bash
   GET /api/accounts
   Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
   ```

**Componentes**:

- `JwtTokenProvider`: Genera y valida tokens
- `JwtAuthenticationFilter`: Intercepta peticiones y valida tokens
- `SecurityConfig`: Define rutas protegidas

**Expiraci√≥n**: Tokens v√°lidos por 24 horas

</details>

<details>
<summary><strong>¬øQu√© hacer si Eureka no muestra los servicios?</strong></summary>

**Checklist de Diagn√≥stico**:

1. **Verificar que Eureka est√© corriendo**:

   ```bash
   curl http://localhost:8761
   # Debe retornar la UI de Eureka
   ```

2. **Revisar logs del servicio**:

   ```bash
   docker logs account-service
   # Buscar: "DiscoveryClient_ACCOUNT-SERVICE"
   ```

3. **Verificar configuraci√≥n**:

   ```yaml
   eureka:
     client:
       service-url:
         defaultZone: http://eureka-server:8761/eureka/
       fetch-registry: true
       register-with-eureka: true
   ```

4. **Esperar el registro**:

   - Los servicios tardan ~30 segundos en aparecer
   - Eureka tiene un mecanismo de cach√©

5. **Revisar networking (Docker)**:
   ```bash
   docker network inspect bank-microservices-cloud_default
   # Verificar que todos los servicios est√©n en la misma red
   ```

</details>

---

## üó∫Ô∏è Roadmap

### üìå v1.0.0 - Sistema Base (Actual)

- ‚úÖ Arquitectura de Microservicios
- ‚úÖ **API Gateway (BFF) con Spring Cloud Gateway**
- ‚úÖ **HTTPS/TLS en puerto 8443 (certificado SSL)**
- ‚úÖ **JWT Authentication centralizado en BFF (GlobalFilter)**
- ‚úÖ Config Server (Centralizado)
- ‚úÖ Eureka Discovery Service
- ‚úÖ Account Service (CRUD + CSV Migration + 11 endpoints legacy)
- ‚úÖ Customer Service (CRUD completo - 8 endpoints)
- ‚úÖ Transaction Service (CRUD completo - 8 endpoints)
- ‚úÖ Patrones de Resiliencia (Resilience4j)
- ‚úÖ PostgreSQL (3 bases de datos independientes)
- ‚úÖ Containerizaci√≥n Docker
- ‚úÖ **Apache Kafka + Zookeeper + Kafka UI**
- ‚úÖ **Event-Driven Architecture (Customer Events)**
- ‚úÖ **Kafka Producer (Customer Service)**
- ‚úÖ **Kafka Consumer (Transaction Service)**
- ‚úÖ **Suite de Tests REST (test-all-endpoints.sh - 100% funcional)**
- ‚úÖ **Suite de Tests Kafka (test-kafka.sh - 100% funcional)**
- ‚úÖ Spring Boot 3.5.0
- ‚úÖ Spring Cloud 2024.0.0
- ‚úÖ Java 21

### üöÄ v1.1.0 - Mejoras de Infraestructura (Pr√≥ximo)

- üîÑ **Tracing Distribuido**

  - Micrometer Tracing
  - Zipkin para visualizaci√≥n
  - Correlaci√≥n de requests entre servicios

- üîÑ **Monitoreo Avanzado**

  - Prometheus para m√©tricas
  - Grafana dashboards
  - Alertas automatizadas

- üîÑ **Cach√© Distribuido**

  - Redis para sesiones
  - Cach√© de consultas frecuentes

- ‚úÖ **Mensajer√≠a As√≠ncrona** _(Completado)_
  - ‚úÖ Apache Kafka implementado
  - ‚úÖ Event-driven architecture
  - ‚úÖ Customer events (create, update, delete)
  - ‚è≥ SAGA Pattern para transacciones distribuidas
  - ‚è≥ Dead Letter Queue (DLQ)
  - ‚è≥ Event Sourcing completo

### üåü v2.0.0 - Escalabilidad y Cloud Native (Futuro)

- ‚è≥ **Programaci√≥n Reactiva**

  - Spring WebFlux
  - Non-blocking I/O
  - Backpressure handling

- ‚è≥ **API GraphQL**

  - Consultas flexibles
  - Reducci√≥n de overfetching

- ‚è≥ **SAGA Pattern**

  - Transacciones distribuidas
  - Compensaci√≥n autom√°tica

- ‚è≥ **Service Mesh**

  - Istio / Linkerd
  - mTLS autom√°tico
  - Observabilidad avanzada

- ‚è≥ **Kubernetes**

  - Orquestaci√≥n de contenedores
  - Auto-scaling
  - Self-healing

- ‚è≥ **CI/CD**
  - GitHub Actions / GitLab CI
  - Despliegue automatizado
  - Tests de integraci√≥n

---

## ÔøΩ Evidencias del Proyecto

### üîê OAuth 2.0 & JWT Authentication

#### Evidencia 1: Generador de Tokens JWT (JwtUtil.java)

![Evidencia 1: JwtUtil.java](evidencias/evidencia_1_oauth_jwt_util.png)

_Implementaci√≥n completa del generador y validador de tokens JWT con firma HMAC-SHA256_

**Caracter√≠sticas**:

- ‚úÖ Generaci√≥n de tokens JWT con expiraci√≥n configurable (24h)
- ‚úÖ Validaci√≥n y verificaci√≥n de firma
- ‚úÖ Extracci√≥n de claims (username, roles)
- ‚úÖ Manejo de excepciones de tokens inv√°lidos/expirados

---

#### Evidencia 2: Filtro de Autenticaci√≥n JWT (JwtAuthenticationFilter.java)

![Evidencia 2: JwtAuthenticationFilter.java](evidencias/evidencia_2_oauth_filter.png)

_Filtro global en API Gateway BFF que intercepta y valida todas las peticiones_

**Caracter√≠sticas**:

- ‚úÖ Interceptaci√≥n de peticiones HTTP en Spring Cloud Gateway
- ‚úÖ Validaci√≥n de token en header `Authorization: Bearer <token>`
- ‚úÖ Exclusi√≥n de rutas p√∫blicas (`/auth/**`, `/actuator/**`)
- ‚úÖ Respuesta 401 para tokens inv√°lidos

---

### üê≥ Dockerizaci√≥n de Microservicios

#### Evidencia 3: Dockerfile Optimizado (Customer Service)

![Evidencia 3: Dockerfile](evidencias/evidencia_3_dockerfile.png)

_Dockerfile con imagen Alpine Linux ultra-ligera para m√°xima eficiencia_

**Caracter√≠sticas**:

- ‚úÖ Imagen base: `eclipse-temurin:21-jre-alpine` (solo JRE, no JDK)
- ‚úÖ Tama√±o reducido: ~215 MB vs ~500 MB con JDK completo
- ‚úÖ Variables de entorno configurables (`JAVA_OPTS`)
- ‚úÖ Security: superficie de ataque m√≠nima

---

#### Evidencia 4: Compilaci√≥n Maven Exitosa

![Evidencia 4: Maven Build](evidencias/evidencia_4_maven_build.png)

_Compilaci√≥n exitosa de los 7 m√≥dulos del proyecto con Maven_

**M√≥dulos compilados**:

1. ‚úÖ bank-microservices-cloud (parent)
2. ‚úÖ config-server
3. ‚úÖ eureka-server
4. ‚úÖ api-gateway-bff
5. ‚úÖ account-service
6. ‚úÖ customer-service
7. ‚úÖ transaction-service

---

#### Evidencia 5: Im√°genes Docker Creadas

![Evidencia 5: Docker Images](evidencias/evidencia_5_docker_images.png)

_6 im√°genes Docker optimizadas con Alpine Linux (180-653 MB cada una)_

**Im√°genes generadas**:

- `bank-microservices-cloud-config-server` (565 MB)
- `bank-microservices-cloud-eureka-server` (591 MB)
- `bank-microservices-cloud-api-gateway-bff` (392 MB)
- `bank-microservices-cloud-account-service` (653 MB)
- `bank-microservices-cloud-customer-service` (480 MB)
- `bank-microservices-cloud-transaction-service` (480 MB)

---

### üéº Orquestaci√≥n con Docker Compose

#### Evidencia 6: Configuraci√≥n docker-compose.yml

![Evidencia 6: docker-compose.yml](evidencias/evidencia_6_docker_compose.png)

_Orquestaci√≥n de 11 contenedores con dependencias y health checks_

**Servicios configurados**:

- **Infrastructure Layer**: postgres, zookeeper, kafka, kafka-ui
- **Spring Cloud Layer**: config-server, eureka-server
- **Microservices Layer**: api-gateway-bff, account-service, customer-service, transaction-service

---

#### Evidencia 7: Contenedores en Ejecuci√≥n

![Evidencia 7: Docker Containers Running](evidencias/evidencia_7_containers_running.png)

_11 contenedores corriendo exitosamente, 10 con estado healthy_

**Estado de contenedores**:

- ‚úÖ 10 contenedores **healthy** (con health checks configurados)
- ‚ö†Ô∏è 1 contenedor **running** (api-gateway-bff - reactive gateway)
- ‚úÖ Todos los puertos mapeados correctamente
- ‚úÖ Red `bank-network` funcionando

---

#### Evidencia 8: Eureka Service Discovery Dashboard

![Evidencia 8: Eureka Server](evidencias/evidencia_8_eureka_dashboard.png)

_Dashboard de Eureka mostrando los 5 microservicios registrados din√°micamente_

**Microservicios registrados**:

- ‚úÖ **API-GATEWAY-BFF** (puerto 8443) - HTTPS Gateway
- ‚úÖ **ACCOUNT-SERVICE** (puerto 8081) - Gesti√≥n de cuentas
- ‚úÖ **CUSTOMER-SERVICE** (puerto 8082) - Gesti√≥n de clientes
- ‚úÖ **TRANSACTION-SERVICE** (puerto 8083) - Gesti√≥n de transacciones
- ‚úÖ **BATCH-SERVICE** (puerto 8084) - Procesamiento por lotes

---

#### Evidencia 9: Kafka UI - Event Streaming

![Evidencia 9: Kafka UI](evidencias/evidencia_9_kafka_ui.png)

_Interfaz de Kafka UI mostrando el cluster y topic de eventos de clientes_

**Configuraci√≥n Kafka**:

- ‚úÖ **Cluster**: bank-cluster
- ‚úÖ **Topic**: customer-created-events (3 partitions)
- ‚úÖ **Zookeeper**: coordinaci√≥n del cluster (puerto 2181)
- ‚úÖ **Kafka Broker**: puerto 9092 (interno) y 29092 (externo)
- ‚úÖ **Kafka UI**: interfaz web en puerto 8090

---

### üöÄ Funcionalidades Extra - Apache Kafka

#### Evidencia 10: Tests de Kafka - Event-Driven Architecture

![Evidencia 10: Kafka Tests](evidencias/evidencia_10_kafka_test.png)

_Suite de pruebas automatizadas de Kafka con 8/8 tests exitosos_

**Tests ejecutados**:

1. ‚úÖ Verificaci√≥n de contenedores Kafka (Zookeeper, Kafka, Kafka UI)
2. ‚úÖ Conectividad a Kafka UI (HTTP 200)
3. ‚úÖ Obtenci√≥n de token JWT del BFF
4. ‚úÖ Creaci√≥n de cliente de prueba (HTTP 201)
5. ‚úÖ Publicaci√≥n de evento CustomerCreated
6. ‚úÖ Consumo de evento en Transaction Service
7. ‚úÖ Creaci√≥n de 3 clientes adicionales
8. ‚úÖ Verificaci√≥n de 4 eventos en total

**Arquitectura Event-Driven**:

- ‚úÖ **Producer**: Customer Service publica eventos al crear clientes
- ‚úÖ **Consumer**: Transaction Service escucha y procesa eventos
- ‚úÖ **Event**: `CustomerCreatedEvent` con datos completos del cliente
- ‚úÖ **Asincron√≠a**: Desacoplamiento entre servicios

---

### üìä Resumen de Evidencias

| Categor√≠a          | Evidencias                                          | Estado                  |
| ------------------ | --------------------------------------------------- | ----------------------- |
| **OAuth 2.0**      | 2 evidencias (JwtUtil, JwtAuthenticationFilter)     | ‚úÖ Completado           |
| **Dockerizaci√≥n**  | 3 evidencias (Dockerfile, Build, Images)            | ‚úÖ Completado           |
| **Docker Compose** | 4 evidencias (Config, Containers, Eureka, Kafka UI) | ‚úÖ Completado           |
| **Kafka (Extra)**  | 1 evidencia (Tests automatizados)                   | ‚úÖ Completado           |
| **Total**          | **10 evidencias**                                   | ‚úÖ **100% Documentado** |

---

## ÔøΩüìö Recursos y Referencias

### Documentaci√≥n Oficial

- [Spring Boot 3.5.x Documentation](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/)
- [Spring Cloud 2024.0.x Documentation](https://docs.spring.io/spring-cloud/docs/current/reference/html/)
- [Resilience4j Official Guide](https://resilience4j.readme.io/)
- [Netflix Eureka Wiki](https://github.com/Netflix/eureka/wiki)

### Art√≠culos Recomendados

- [Microservices Patterns - Chris Richardson](https://microservices.io/patterns/index.html)
- [The Twelve-Factor App](https://12factor.net/)
- [Circuit Breaker Pattern - Martin Fowler](https://martinfowler.com/bliki/CircuitBreaker.html)
- [SAGA Pattern Explained](https://microservices.io/patterns/data/saga.html)

### Tutoriales

- [Spring Cloud Netflix Eureka Tutorial](https://spring.io/guides/gs/service-registration-and-discovery/)
- [Resilience4j with Spring Boot](https://resilience4j.readme.io/docs/getting-started-3)
- [Docker Compose for Microservices](https://docs.docker.com/compose/gettingstarted/)

---

## üìë Tabla de Contenidos

- [Descripci√≥n](#-descripci√≥n)
- [Arquitectura](#Ô∏è-arquitectura)
- [Componentes](#-componentes)
- [Modelo de Datos](#-modelo-de-datos)
- [Stack Tecnol√≥gico](#Ô∏è-stack-tecnol√≥gico)
- [Inicio R√°pido](#-inicio-r√°pido)
- [Seguridad](#-seguridad)
- [Patrones de Resiliencia](#Ô∏è-patrones-de-resiliencia)
- [Testing y Calidad](#-testing-y-calidad)
- [Monitoreo y Observabilidad](#-monitoreo-y-observabilidad)
- [Preguntas Frecuentes (FAQ)](#-preguntas-frecuentes-faq)
- [Roadmap](#Ô∏è-roadmap)
- [Evidencias del Proyecto](#-evidencias-del-proyecto)
- [Recursos y Referencias](#-recursos-y-referencias)
- [Estructura del Proyecto](#-estructura-del-proyecto)
- [Patrones Implementados](#-patrones-implementados)
- [Despliegue en Producci√≥n](#-despliegue-en-producci√≥n)
- [Contribuciones](#-contribuciones)
- [Contacto](#-contacto)
- [Licencia](#-licencia)

---

## üìã Descripci√≥n

Plataforma empresarial de microservicios para gesti√≥n bancaria que implementa patrones avanzados de resiliencia, configuraci√≥n centralizada, descubrimiento de servicios y seguridad distribuida mediante Spring Cloud y Resilience4j.

### Caracter√≠sticas Principales

- ‚úÖ **Arquitectura de Microservicios** escalable y distribuida
- ‚úÖ **API Gateway (BFF)** con Spring Cloud Gateway Reactive
- ‚úÖ **HTTPS/TLS** con certificado SSL auto-firmado (puerto 8443)
- ‚úÖ **Autenticaci√≥n JWT Centralizada** en API Gateway (sin Spring Security)
- ‚úÖ **Event-Driven Architecture** con Apache Kafka
- ‚úÖ **Kafka UI** para visualizaci√≥n de eventos en tiempo real (puerto 8090)
- ‚úÖ **4 Microservicios de Negocio** (Account, Customer, Transaction, Batch)
- ‚úÖ **27 Endpoints Funcionales** (11 Account + 8 Customer + 8 Transaction)
- ‚úÖ **Spring Batch** para procesamiento de datos legacy y jobs programados
- ‚úÖ **Mensajer√≠a As√≠ncrona** (Producer/Consumer con Spring Kafka)
- ‚úÖ **Configuraci√≥n Centralizada** con Spring Cloud Config
- ‚úÖ **Service Discovery** con Netflix Eureka
- ‚úÖ **Patrones de Resiliencia** (Circuit Breaker, Retry, Rate Limiting)
- ‚úÖ **Contenedorizaci√≥n** con Docker y Docker Compose (11 contenedores)
- ‚úÖ **API RESTful** documentada con Swagger/OpenAPI
- ‚úÖ **Monitoreo** con Spring Actuator
- ‚úÖ **Bases de Datos Independientes** por microservicio
- ‚úÖ **Suite de Tests Automatizada** (REST + Kafka - 100% funcional)

---

## üèóÔ∏è Arquitectura

### Diagrama de Componentes

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          API Gateway BFF (8443 HTTPS)                   ‚îÇ
‚îÇ      JWT Authentication + Routing + Circuit Breaker     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                                           ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇConfig Server ‚îÇ                          ‚îÇ Eureka Server   ‚îÇ
‚îÇ   (8888)     ‚îÇ                          ‚îÇ    (8761)       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                   ‚îÇ
                        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                        ‚îÇ                          ‚îÇ                      ‚îÇ
                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                 ‚îÇ   Account   ‚îÇ         ‚îÇ   Customer    ‚îÇ ‚îÇTransaction  ‚îÇ ‚îÇ   Batch    ‚îÇ
                 ‚îÇ   Service   ‚îÇ         ‚îÇ    Service    ‚îÇ ‚îÇ   Service   ‚îÇ ‚îÇ  Service   ‚îÇ
                 ‚îÇ   (8081)    ‚îÇ         ‚îÇ    (8082)     ‚îÇ ‚îÇ   (8083)    ‚îÇ ‚îÇ  (8084)    ‚îÇ
                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ                        ‚îÇ               ‚îÇ              ‚îÇ
                        ‚îÇ                        ‚îÇ Kafka         ‚îÇ Kafka        ‚îÇ Spring
                        ‚îÇ                        ‚îÇ Producer      ‚îÇ Consumer     ‚îÇ Batch
                        ‚îÇ                        ‚îÇ               ‚îÇ              ‚îÇ Jobs
                        ‚îÇ                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îê
                        ‚îÇ                 ‚îÇ       Apache Kafka (9092)              ‚îÇ
                        ‚îÇ                 ‚îÇ     customer-created-events            ‚îÇ
                        ‚îÇ                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ                        ‚îÇ         ‚îÇ            ‚îÇ
                        ‚îÇ                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
                        ‚îÇ                 ‚îÇZookeeper‚îÇ  ‚îÇ  Kafka UI  ‚îÇ   ‚îÇ
                        ‚îÇ                 ‚îÇ (2181)  ‚îÇ  ‚îÇ   (8090)   ‚îÇ   ‚îÇ
                        ‚îÇ                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
                        ‚îÇ                                                ‚îÇ
                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                 ‚îÇ
                                          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                          ‚îÇ PostgreSQL  ‚îÇ
                                          ‚îÇ   (5432)    ‚îÇ
                                          ‚îÇ  4 Databases‚îÇ
                                          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Principios Arquitect√≥nicos

- **Independencia de Servicios**: Cada microservicio puede desplegarse independientemente
- **Configuraci√≥n Externalizada**: Configuraciones centralizadas en Config Server
- **Descubrimiento Din√°mico**: Registro autom√°tico de servicios en Eureka
- **Resiliencia**: Implementaci√≥n de Circuit Breaker, Retry y Rate Limiting
- **Seguridad Distribuida**: Autenticaci√≥n JWT en cada microservicio

---

## üöÄ Componentes

### Config Server (Puerto 8888)

**Servidor de configuraci√≥n centralizada**

- Gestiona configuraciones de todos los microservicios
- Soporte para perfiles de ambiente (dev, prod)
- Actualizaci√≥n de configuraci√≥n en tiempo real

### Eureka Server (Puerto 8761)

**Service Discovery y Service Registry**

- Registro autom√°tico de microservicios
- Dashboard web para monitoreo
- Detecci√≥n de servicios ca√≠dos (heartbeat)
- Balanceo de carga del lado del cliente

### Account Service (Puerto 8081)

**Microservicio de gesti√≥n bancaria**

**Caracter√≠sticas**:

- API RESTful para operaciones CRUD de cuentas
- Procesamiento de datos legacy del sistema bancario
- Autenticaci√≥n y autorizaci√≥n JWT
- Integraci√≥n con PostgreSQL mediante JPA
- Documentaci√≥n Swagger/OpenAPI
- M√©tricas y health checks con Actuator

**Patrones de Resiliencia**:

- Circuit Breaker (protecci√≥n contra fallos en cascada)
- Retry (reintentos autom√°ticos)
- Rate Limiter (control de tr√°fico: 10 req/s)
- Time Limiter (timeout en operaciones)

### Customer Service (Puerto 8082)

**Microservicio de gesti√≥n de clientes**

**Caracter√≠sticas**:

- API RESTful para gesti√≥n completa de clientes
- Validaci√≥n de RUT √∫nico
- Estados de cliente (ACTIVE, INACTIVE, SUSPENDED, BLOCKED)
- Autenticaci√≥n y autorizaci√≥n JWT
- Integraci√≥n con PostgreSQL mediante JPA
- M√©tricas y health checks con Actuator

**Endpoints Principales**:

- `GET /api/customers` - Listar todos los clientes
- `GET /api/customers/{id}` - Obtener cliente por ID
- `GET /api/customers/rut/{rut}` - Buscar por RUT
- `GET /api/customers/email/{email}` - Buscar por email
- `POST /api/customers` - Crear cliente
- `PUT /api/customers/{id}` - Actualizar cliente
- `DELETE /api/customers/{id}` - Eliminar cliente

**Patrones de Resiliencia**:

- Circuit Breaker (protecci√≥n contra fallos en cascada)
- Retry (reintentos autom√°ticos con backoff exponencial)
- Rate Limiter (control de tr√°fico: 10 req/s)
- Time Limiter (timeout de 3 segundos)

### Transaction Service (Puerto 8083)

**Microservicio de gesti√≥n de transacciones bancarias**

**Caracter√≠sticas**:

- API RESTful para procesamiento de transacciones
- Tipos: DEPOSIT, WITHDRAWAL, TRANSFER, PAYMENT, FEE
- Estados: PENDING, COMPLETED, FAILED, CANCELLED, REVERSED
- Autenticaci√≥n y autorizaci√≥n JWT
- Integraci√≥n con PostgreSQL mediante JPA
- M√©tricas y health checks con Actuator

**Endpoints Principales**:

- `GET /api/transactions` - Listar todas las transacciones
- `GET /api/transactions/{id}` - Obtener transacci√≥n por ID
- `GET /api/transactions/account/{accountId}` - Por cuenta
- `GET /api/transactions/customer/{customerId}` - Por cliente
- `POST /api/transactions` - Crear transacci√≥n
- `PUT /api/transactions/{id}` - Actualizar transacci√≥n
- `DELETE /api/transactions/{id}` - Eliminar transacci√≥n

**Patrones de Resiliencia**:

- Circuit Breaker (protecci√≥n contra fallos en cascada)
- Retry (reintentos autom√°ticos con backoff exponencial)
- Rate Limiter (control de tr√°fico: 10 req/s)
- Time Limiter (timeout de 3 segundos)

### Batch Service (Puerto 8084)

**Microservicio de procesamiento por lotes con Spring Batch**

**Caracter√≠sticas**:

- Migraci√≥n de procesos COBOL legacy a Spring Batch
- Procesamiento masivo de transacciones bancarias
- Jobs configurables con steps y chunks
- Validaci√≥n autom√°tica de datos
- Manejo de errores y reintentos
- Reportes de ejecuci√≥n y m√©tricas

**Procesos Batch Implementados**:

1. **Validaci√≥n de Transacciones Legacy** (`validateTransactionsJob`)

   - Lee transacciones desde archivo CSV legacy
   - Valida formato y reglas de negocio
   - Genera reporte de transacciones inv√°lidas
   - Chunk size: 100 registros

2. **Carga de Cuentas Legacy** (`loadLegacyAccountsJob`)

   - Importa cuentas desde sistema COBOL
   - Normaliza formatos de datos
   - Valida integridad referencial
   - Chunk size: 50 registros

3. **C√°lculo de Intereses Mensuales** (`calculateInterestsJob`)
   - Procesa todas las cuentas activas
   - Aplica tasas seg√∫n tipo de cuenta
   - Genera movimientos de inter√©s
   - Ejecuci√≥n programada: √öltimo d√≠a del mes

**Endpoints REST**:

- `POST /batch/jobs/{jobName}` - Ejecutar job manualmente
- `GET /batch/jobs` - Listar todos los jobs
- `GET /batch/jobs/{jobName}/executions` - Historial de ejecuciones
- `GET /batch/jobs/executions/{executionId}` - Detalle de ejecuci√≥n

**Caracter√≠sticas Spring Batch**:

- JobRepository para tracking de ejecuciones
- ItemReader/ItemProcessor/ItemWriter pattern
- Skip logic para errores no cr√≠ticos
- Restart capability para jobs fallidos
- Listeners para logging y m√©tricas

**Ejemplo de Ejecuci√≥n**:

```bash
# Ejecutar job de validaci√≥n
curl -X POST http://localhost:8084/batch/jobs/validateTransactionsJob

# Ver resultado
{
  "jobId": 1,
  "jobName": "validateTransactionsJob",
  "status": "COMPLETED",
  "startTime": "2025-10-11T10:00:00",
  "endTime": "2025-10-11T10:05:30",
  "exitCode": "COMPLETED",
  "itemsRead": 1020,
  "itemsProcessed": 1015,
  "itemsWritten": 1015,
  "skipCount": 5
}
```

**Migraci√≥n Legacy**:

- ‚úÖ Reemplaza scripts COBOL batch nocturnos
- ‚úÖ Procesamiento paralelo con partitioning
- ‚úÖ Monitoreo en tiempo real vs. logs offline
- ‚úÖ Rollback autom√°tico ante fallos

### Apache Kafka (Puertos 9092/29092)

**Sistema de mensajer√≠a distribuida para Event-Driven Architecture**

**Caracter√≠sticas**:

- Event Streaming para comunicaci√≥n as√≠ncrona entre microservicios
- Arquitectura Pub/Sub de alto rendimiento
- Persistencia de eventos para auditor√≠a
- Procesamiento de eventos en tiempo real

**Componentes Kafka**:

1. **Zookeeper** (Puerto 2181)

   - Coordinaci√≥n de cluster Kafka
   - Gesti√≥n de metadatos
   - Healthcheck: `cub zk-ready`

2. **Kafka Broker** (Puertos 9092/29092)

   - Broker principal de mensajes
   - Auto-creaci√≥n de topics habilitada
   - Replication factor: 1 (desarrollo)
   - Healthcheck: `cub kafka-ready`

3. **Kafka UI** (Puerto 8090)
   - Interfaz web para visualizaci√≥n de mensajes
   - Monitoreo de topics y consumers
   - Visualizaci√≥n de eventos en tiempo real
   - Acceso: `http://localhost:8090`

**Topics Implementados**:

- **`customer-created-events`** (3 particiones)
  - Eventos de creaci√≥n de clientes
  - Producer: Customer Service
  - Consumer: Transaction Service
  - Formato: JSON con CustomerCreatedEvent

**Flujo de Eventos**:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Customer Service ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ  Kafka Topic  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇTransaction Service ‚îÇ
‚îÇ   (Producer)     ‚îÇ Publish ‚îÇcustomer-created‚îÇConsume ‚îÇ   (Consumer)       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ    -events    ‚îÇ        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Event Schema** (CustomerCreatedEvent):

```json
{
  "customerId": 123,
  "rut": "12345678-9",
  "firstName": "John",
  "lastName": "Doe",
  "email": "john.doe@example.com",
  "phone": "+56912345678",
  "status": "ACTIVE",
  "createdAt": "2025-10-06T21:18:41.350236046"
}
```

**Uso**:

1. **Verificar Kafka UI**:

   ```bash
   # Abrir en navegador
   open http://localhost:8090
   ```

2. **Ver topics desde terminal**:

   ```bash
   docker exec -it bank-kafka kafka-topics \
     --bootstrap-server localhost:9092 --list
   ```

3. **Consumir mensajes**:

   ```bash
   docker exec -it bank-kafka kafka-console-consumer \
     --bootstrap-server localhost:9092 \
     --topic customer-created-events \
     --from-beginning
   ```

4. **Ver logs del consumer**:
   ```bash
   docker logs bank-transaction-service | grep "CustomerCreated"
   ```

**Beneficios**:

- ‚úÖ **Desacoplamiento**: Servicios no dependen directamente entre s√≠
- ‚úÖ **Escalabilidad**: Procesamiento as√≠ncrono de eventos
- ‚úÖ **Auditor√≠a**: Todos los eventos quedan registrados
- ‚úÖ **Resiliencia**: Eventos persistentes ante fallos
- ‚úÖ **Event Sourcing**: Reconstrucci√≥n del estado desde eventos

### API Gateway (Puerto 8080)

**Punto de entrada unificado** _(Opcional - Recomendado para producci√≥n)_

- Enrutamiento inteligente de peticiones
- Autenticaci√≥n centralizada
- Rate limiting global
- Logging y monitoreo centralizado

---

## üìä Modelo de Datos

### Entidades Principales

**Cuentas Bancarias** (`accounts`)

- Gesti√≥n completa de cuentas
- Tipos: Ahorros, Corriente, N√≥mina
- Control de saldos y estados
- Base de datos: `bankdb`

**Clientes** (`customers`)

- Gesti√≥n de informaci√≥n de clientes
- Validaci√≥n de RUT √∫nico
- Email √∫nico por cliente
- Estados: ACTIVE, INACTIVE, SUSPENDED, BLOCKED
- Base de datos: `customerdb`

**Transacciones** (`transactions`)

- Registro de movimientos financieros
- Tipos: DEPOSIT, WITHDRAWAL, TRANSFER, PAYMENT, FEE
- Estados: PENDING, COMPLETED, FAILED, CANCELLED, REVERSED
- Relaci√≥n con cuentas y clientes
- Base de datos: `transactiondb`

**Intereses** (`interests`)

- C√°lculo autom√°tico de intereses
- Aplicaci√≥n mensual seg√∫n tipo de cuenta
- Historial de aplicaciones
- Base de datos: `bankdb`

**Usuarios** (`users`)

- Autenticaci√≥n y autorizaci√≥n
- Roles: ADMIN, USER
- Gesti√≥n de credenciales JWT
- Base de datos: compartida

### Referencia de Datos Legacy

Basado en el dataset [bank_legacy_data](https://github.com/KariVillagran/bank_legacy_data) para procesamiento de informaci√≥n hist√≥rica.

---

## üõ†Ô∏è Stack Tecnol√≥gico

| Tecnolog√≠a      | Versi√≥n  | Prop√≥sito                     |
| --------------- | -------- | ----------------------------- |
| Java            | 21       | Lenguaje de programaci√≥n      |
| Spring Boot     | 3.5.0    | Framework de aplicaci√≥n       |
| Spring Cloud    | 2024.0.0 | Framework de microservicios   |
| Spring Security | 6.x      | Seguridad y autenticaci√≥n     |
| Spring Kafka    | 3.3.6    | Integraci√≥n con Apache Kafka  |
| Resilience4j    | 2.x      | Patrones de resiliencia       |
| Apache Kafka    | 3.9.1    | Event Streaming Platform      |
| Zookeeper       | 7.5.0    | Coordinaci√≥n de Kafka cluster |
| Kafka UI        | Latest   | Interfaz web para Kafka       |
| PostgreSQL      | 15+      | Base de datos relacional      |
| Docker          | Latest   | Contenedorizaci√≥n             |
| Maven           | 3.8+     | Gesti√≥n de dependencias       |
| Lombok          | 1.18.34  | Reducci√≥n de boilerplate      |

---

## üöÄ Inicio R√°pido

### Requisitos Previos

- **JDK**: 21 o superior
- **Maven**: 3.8 o superior
- **Docker**: 20.10 o superior
- **Docker Compose**: 2.0 o superior

### Instalaci√≥n

#### Opci√≥n 1: Docker Compose (Recomendado)

```bash
# Clonar el repositorio
git clone https://github.com/RodrigoSanchezDev/bank-microservices-cloud.git
cd bank-microservices-cloud

# Construir y levantar todos los servicios
docker-compose up -d

# Verificar estado
docker-compose ps

# Ver logs
docker-compose logs -f

# Detener servicios
docker-compose down
```

#### Opci√≥n 2: Ejecuci√≥n Local

```bash
# 1. Compilar
mvn clean install -DskipTests

# 2. Iniciar Config Server (Terminal 1)
cd config-server && mvn spring-boot:run

# 3. Iniciar Eureka Server (Terminal 2)
cd eureka-server && mvn spring-boot:run

# 4. Iniciar Account Service (Terminal 3)
cd account-service && mvn spring-boot:run

# 5. Iniciar Customer Service (Terminal 4)
cd customer-service && mvn spring-boot:run

# 6. Iniciar Transaction Service (Terminal 5)
cd transaction-service && mvn spring-boot:run
```

### Verificaci√≥n

Espera ~60 segundos para que los servicios se registren.

**Servicios Core**:

- **Config Server**: http://localhost:8888/actuator/health
- **Eureka Dashboard**: http://localhost:8761
- **API Gateway BFF**: https://localhost:8443/actuator/health

**Microservicios**:

- **Account Service**: http://localhost:8081/actuator/health
- **Customer Service**: http://localhost:8082/actuator/health
- **Transaction Service**: http://localhost:8083/actuator/health

**Mensajer√≠a y UI**:

- **Kafka UI**: http://localhost:8090 (Visualizaci√≥n de eventos)
- **Zookeeper**: localhost:2181 (Coordinaci√≥n Kafka)
- **Kafka Broker**: localhost:9092 (Interno), localhost:29092 (Externo)

**Base de Datos**:

- **PostgreSQL**: localhost:5432 (bankdb, customerdb, transactiondb)

**Swagger UI**:

- http://localhost:8081/swagger-ui.html (Account)
- http://localhost:8082/swagger-ui.html (Customer)
- http://localhost:8083/swagger-ui.html (Transaction)

---

## üìç Endpoints Principales

### Eureka Dashboard

```
http://localhost:8761
```

### Config Server

```
http://localhost:8888/account-service/default
```

### Account Service API

**Autenticaci√≥n (Obtener JWT)**

> ‚ö†Ô∏è **IMPORTANTE**: Todos los endpoints ahora est√°n expuestos a trav√©s del **API Gateway BFF** en puerto **8443 (HTTPS)**

```bash
# Login - Obtener JWT (usuario admin)
curl -k -X POST https://localhost:8443/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "admin",
    "password": "admin123"
  }'

# Login - Obtener JWT (usuario regular)
curl -k -X POST https://localhost:8443/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "user",
    "password": "user123"
  }'
```

**Respuesta**:

```json
{
  "token": "eyJhbGciOiJIUzI1NiJ9...",
  "username": "admin"
}
```

### Operaciones de Cuentas (requiere JWT)

```bash
# Listar cuentas
curl -k -X GET https://localhost:8443/api/accounts \
  -H "Authorization: Bearer {token}"

# Crear cuenta
curl -k -X POST https://localhost:8443/api/accounts \
  -H "Authorization: Bearer {token}" \
  -H "Content-Type: application/json" \
  -d '{
    "accountNumber": "1234567890",
    "accountHolder": "Juan P√©rez",
    "balance": 1000.00,
    "accountType": "SAVINGS"
  }'

# Obtener cuenta por ID
curl -k -X GET https://localhost:8443/api/accounts/{id} \
  -H "Authorization: Bearer {token}"

# Account Legacy Endpoints (11 endpoints)
curl -k -X GET https://localhost:8443/api/accounts/legacy/transacciones \
  -H "Authorization: Bearer {token}"

curl -k -X GET https://localhost:8443/api/accounts/legacy/intereses \
  -H "Authorization: Bearer {token}"

curl -k -X GET https://localhost:8443/api/accounts/legacy/cuentas-anuales \
  -H "Authorization: Bearer {token}"

curl -k -X GET https://localhost:8443/api/accounts/legacy/resumen-general \
  -H "Authorization: Bearer {token}"
```

### Customer Service API

**Operaciones de Clientes (8 endpoints - requiere JWT)**

```bash
# Listar todos los clientes
curl -k -X GET https://localhost:8443/api/customers \
  -H "Authorization: Bearer {token}"

# Crear cliente
curl -k -X POST https://localhost:8443/api/customers \
  -H "Authorization: Bearer {token}" \
  -H "Content-Type: application/json" \
  -d '{
    "rut": "12345678-9",
    "firstName": "Juan",
    "lastName": "P√©rez",
    "email": "juan.perez@example.com",
    "phone": "+56912345678",
    "address": "Santiago, Chile",
    "status": "ACTIVE"
  }'

# Buscar por RUT
curl -k -X GET https://localhost:8443/api/customers/rut/12345678-9 \
  -H "Authorization: Bearer {token}"

# Buscar por email
curl -k -X GET https://localhost:8443/api/customers/email/juan.perez@example.com \
  -H "Authorization: Bearer {token}"

# Actualizar cliente
curl -k -X PUT https://localhost:8443/api/customers/{id} \
  -H "Authorization: Bearer {token}" \
  -H "Content-Type: application/json" \
  -d '{
    "firstName": "Juan Carlos",
    "lastName": "P√©rez Gonz√°lez",
    "status": "ACTIVE"
  }'

# Eliminar cliente
curl -k -X DELETE https://localhost:8443/api/customers/{id} \
  -H "Authorization: Bearer {token}"

# Health check
curl -k -X GET https://localhost:8443/api/customers/health \
  -H "Authorization: Bearer {token}"
```

### Transaction Service API

**Operaciones de Transacciones (8 endpoints - requiere JWT)**

```bash
# Listar todas las transacciones
curl -k -X GET https://localhost:8443/api/transactions \
  -H "Authorization: Bearer {token}"

# Crear transacci√≥n
curl -k -X POST https://localhost:8443/api/transactions \
  -H "Authorization: Bearer {token}" \
  -H "Content-Type: application/json" \
  -d '{
    "accountId": 1,
    "customerId": 1,
    "type": "DEPOSIT",
    "amount": 50000.00,
    "description": "Dep√≥sito inicial",
    "status": "PENDING"
  }'

# Buscar transacciones por cuenta
curl -k -X GET https://localhost:8443/api/transactions/account/{accountId} \
  -H "Authorization: Bearer {token}"

# Buscar transacciones por cliente
curl -k -X GET https://localhost:8443/api/transactions/customer/{customerId} \
  -H "Authorization: Bearer {token}"

# Actualizar transacci√≥n
curl -k -X PUT https://localhost:8443/api/transactions/{id} \
  -H "Authorization: Bearer {token}" \
  -H "Content-Type: application/json" \
  -d '{
    "status": "COMPLETED"
  }'

# Eliminar transacci√≥n
curl -k -X DELETE https://localhost:8443/api/transactions/{id} \
  -H "Authorization: Bearer {token}"

# Health check
curl -k -X GET https://localhost:8443/api/transactions/health \
  -H "Authorization: Bearer {token}"
```

---

## üß™ Suite de Tests Automatizada

El proyecto incluye **dos scripts completos de tests**:

### 1. Test de Endpoints REST (test-all-endpoints.sh)

Valida **todos los 27 endpoints** a trav√©s del API Gateway BFF con HTTPS y JWT.

```bash
# Ejecutar suite completa de tests
./test-all-endpoints.sh

# Ver logs en tiempo real
./test-all-endpoints.sh 2>&1 | tee test-results.log
```

### 2. Test de Mensajer√≠a Kafka (test-kafka.sh)

Valida **Event-Driven Architecture** con Apache Kafka.

```bash
# Ejecutar tests de Kafka
./test-kafka.sh

# Resultado esperado:
# ‚úÖ 4 clientes creados
# ‚úÖ 4 eventos publicados a Kafka
# ‚úÖ 4 eventos consumidos correctamente
# ‚úÖ Kafka UI disponible en http://localhost:8090
```

**Qu√© valida**:

- ‚úÖ Contenedores Kafka, Zookeeper y Kafka UI est√°n healthy
- ‚úÖ Topic `customer-created-events` creado con 3 particiones
- ‚úÖ Producer en Customer Service publica eventos
- ‚úÖ Consumer en Transaction Service procesa eventos
- ‚úÖ Kafka UI muestra mensajes en tiempo real

**Verificaci√≥n manual**:

```bash
# Ver mensajes en Kafka UI
open http://localhost:8090

# Ver eventos desde terminal
docker exec -it bank-kafka kafka-console-consumer \
  --bootstrap-server localhost:9092 \
  --topic customer-created-events \
  --from-beginning

# Ver logs del consumer
docker logs bank-transaction-service | grep "CustomerCreated"
```

### Resumen de Endpoints

**Account Service (11 endpoints legacy)**:

- ‚úÖ GET `/api/accounts/legacy/transacciones` - Lista transacciones v√°lidas/inv√°lidas
- ‚úÖ GET `/api/accounts/legacy/transacciones-validas` - Solo transacciones v√°lidas
- ‚úÖ GET `/api/accounts/legacy/transacciones-invalidas` - Solo transacciones inv√°lidas
- ‚úÖ GET `/api/accounts/legacy/intereses` - C√°lculos de intereses
- ‚úÖ GET `/api/accounts/legacy/intereses-validos` - Intereses v√°lidos
- ‚úÖ GET `/api/accounts/legacy/intereses-invalidos` - Intereses inv√°lidos
- ‚úÖ GET `/api/accounts/legacy/cuentas-anuales` - Cuentas anuales
- ‚úÖ GET `/api/accounts/legacy/cuentas-validas` - Cuentas v√°lidas
- ‚úÖ GET `/api/accounts/legacy/cuentas-invalidas` - Cuentas inv√°lidas
- ‚úÖ GET `/api/accounts/legacy/resumen-general` - Resumen completo
- ‚úÖ GET `/api/accounts/legacy/health` - Health check

**Customer Service (8 endpoints CRUD)**:

- ‚úÖ GET `/api/customers` - Listar todos los clientes
- ‚úÖ GET `/api/customers/{id}` - Obtener cliente por ID
- ‚úÖ GET `/api/customers/rut/{rut}` - Buscar por RUT
- ‚úÖ GET `/api/customers/email/{email}` - Buscar por email
- ‚úÖ POST `/api/customers` - Crear cliente
- ‚úÖ PUT `/api/customers/{id}` - Actualizar cliente
- ‚úÖ DELETE `/api/customers/{id}` - Eliminar cliente
- ‚úÖ GET `/api/customers/health` - Health check

**Transaction Service (8 endpoints CRUD)**:

- ‚úÖ GET `/api/transactions` - Listar todas las transacciones
- ‚úÖ GET `/api/transactions/{id}` - Obtener transacci√≥n por ID
- ‚úÖ GET `/api/transactions/account/{accountId}` - Transacciones por cuenta
- ‚úÖ GET `/api/transactions/customer/{customerId}` - Transacciones por cliente
- ‚úÖ POST `/api/transactions` - Crear transacci√≥n
- ‚úÖ PUT `/api/transactions/{id}` - Actualizar transacci√≥n
- ‚úÖ DELETE `/api/transactions/{id}` - Eliminar transacci√≥n
- ‚úÖ GET `/api/transactions/health` - Health check

### Resultado Esperado

```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                  RESUMEN DE TESTS                     ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

Total de tests ejecutados: 17
Tests exitosos: 17
Tests fallidos: 0

‚úì ¬°Todos los tests pasaron exitosamente!
‚úì BFF HTTPS funcionando correctamente
‚úì JWT authentication funcionando
‚úì Routing a microservicios funcionando

‚Ñπ ENDPOINTS TOTALES DISPONIBLES:
  - Account Service (Legacy): 11 endpoints
  - Customer Service (CRUD): 8 endpoints
  - Transaction Service (CRUD): 8 endpoints
  Total: 27 endpoints expuestos a trav√©s del BFF
PUT http://localhost:8083/api/transactions/{id}
Authorization: Bearer {token}
Content-Type: application/json

{
  "status": "COMPLETED",
  "description": "Transacci√≥n completada exitosamente"
}
```

### Health & Monitoreo

```bash
# Health check - Account Service
GET http://localhost:8081/actuator/health

# Health check - Customer Service
GET http://localhost:8082/actuator/health

# Health check - Transaction Service
GET http://localhost:8083/actuator/health

# Circuit Breaker estado
GET http://localhost:8081/actuator/health/circuitbreakers
GET http://localhost:8082/actuator/health/circuitbreakers
GET http://localhost:8083/actuator/health/circuitbreakers

# M√©tricas
GET http://localhost:8081/actuator/metrics
GET http://localhost:8082/actuator/metrics
GET http://localhost:8083/actuator/metrics
```

---

## üîí Seguridad

### Autenticaci√≥n JWT

**Configuraci√≥n**:

- Algoritmo: HS512
- Tiempo de vida: 24 horas
- Claims: username, roles, authorities

**Credenciales por Defecto**:

- Username: `admin`
- Password: `admin123`
- Rol: `ADMIN`

‚ö†Ô∏è **Importante**: Cambia las credenciales en producci√≥n y utiliza variables de entorno.

### Endpoints Protegidos

- ‚úÖ Todos los endpoints bajo `/api/accounts` requieren autenticaci√≥n
- ‚úÖ Endpoints administrativos requieren rol `ADMIN`
- ‚úÖ Endpoints de lectura disponibles para rol `USER`
- ‚ùå Endpoints p√∫blicos: `/api/auth/login`, `/actuator/health`

---

## üõ°Ô∏è Patrones de Resiliencia

### Circuit Breaker (Resilience4j)

**Configuraci√≥n**:

```yaml
slidingWindowSize: 10
failureRateThreshold: 50
waitDurationInOpenState: 10s
permittedNumberOfCallsInHalfOpenState: 3
```

**Estados**:

- **CLOSED**: Operaci√≥n normal, todas las peticiones pasan
- **OPEN**: Umbral alcanzado, peticiones fallan r√°pidamente
- **HALF_OPEN**: Prueba si el servicio se recuper√≥

### Retry Pattern

**Configuraci√≥n**:

```yaml
maxAttempts: 3
waitDuration: 2s
retryExceptions:
  - java.io.IOException
  - java.util.concurrent.TimeoutException
```

**Estrategia**: Exponential backoff con jitter

### Rate Limiter

**Configuraci√≥n**:

```yaml
limitForPeriod: 10
limitRefreshPeriod: 1m
timeoutDuration: 0
```

**Protecci√≥n**: L√≠mite de 10 peticiones por minuto por endpoint

### Time Limiter

**Configuraci√≥n**:

```yaml
timeoutDuration: 5s
cancelRunningFuture: true
```

**Objetivo**: Prevenir operaciones de larga duraci√≥n

---

## üß™ Testing y Calidad

### Suite de Tests Automatizados

```bash
# Ejecutar tests unitarios
mvn clean test

# Tests de un m√≥dulo espec√≠fico
cd account-service && mvn test

# Reporte de cobertura
mvn clean test jacoco:report
```

### Script de Evaluaci√≥n Completa (Alternativa)

Para una **verificaci√≥n integral del sistema** con interfaz interactiva:

```bash
# Dar permisos de ejecuci√≥n
chmod +x test-evaluacion-final.sh

# Ejecutar men√∫ interactivo
./test-evaluacion-final.sh
```

**Incluye 22 tests organizados en 6 categor√≠as**:

- ‚úÖ Migraci√≥n de Procesos Batch (4 tests)
- ‚úÖ Patr√≥n BFF Multi-Canal (5 tests)
- ‚úÖ Microservicios Resilientes (3 tests)
- ‚úÖ Seguridad Distribuida JWT/HTTPS (3 tests)
- ‚úÖ Mensajer√≠a As√≠ncrona Kafka (3 tests)
- ‚úÖ Containerizaci√≥n Docker (4 tests)

Ver [GUIA-RAPIDA-USO.md](GUIA-RAPIDA-USO.md) para m√°s detalles.

### Colecci√≥n Postman

Importa `postman-collection.json` para probar todos los endpoints.

---

## üìä Monitoreo y Observabilidad

### Spring Actuator

**Account Service**:

```bash
# Health check
curl http://localhost:8081/actuator/health

# M√©tricas
curl http://localhost:8081/actuator/metrics

# Info
curl http://localhost:8081/actuator/info

# Circuit Breaker
curl http://localhost:8081/actuator/health/circuitbreakers
```

**Customer Service**:

```bash
# Health check
curl http://localhost:8082/actuator/health

# M√©tricas
curl http://localhost:8082/actuator/metrics

# Circuit Breaker
curl http://localhost:8082/actuator/health/circuitbreakers
```

**Transaction Service**:

```bash
# Health check
curl http://localhost:8083/actuator/health

# M√©tricas
curl http://localhost:8083/actuator/metrics

# Circuit Breaker
curl http://localhost:8083/actuator/health/circuitbreakers
```

### Eureka Dashboard

```bash
# Ver todos los servicios registrados
curl http://localhost:8761/eureka/apps

# Ver servicio espec√≠fico
curl http://localhost:8761/eureka/apps/ACCOUNT-SERVICE
curl http://localhost:8761/eureka/apps/CUSTOMER-SERVICE
curl http://localhost:8761/eureka/apps/TRANSACTION-SERVICE
```

---

## üìÅ Estructura del Proyecto

```
bank-microservices-cloud/
‚îú‚îÄ‚îÄ config-server/              # Configuraci√≥n centralizada
‚îÇ   ‚îî‚îÄ‚îÄ src/main/resources/
‚îÇ       ‚îî‚îÄ‚îÄ config-repo/        # Configuraciones de servicios
‚îÇ           ‚îú‚îÄ‚îÄ account-service.yml
‚îÇ           ‚îú‚îÄ‚îÄ customer-service.yml
‚îÇ           ‚îî‚îÄ‚îÄ transaction-service.yml
‚îú‚îÄ‚îÄ eureka-server/              # Service Discovery
‚îú‚îÄ‚îÄ account-service/            # Microservicio de cuentas
‚îÇ   ‚îú‚îÄ‚îÄ src/main/java/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ com/duoc/bank/account/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ config/         # Configuraci√≥n
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ controller/     # REST Controllers
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ dto/            # Data Transfer Objects
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ model/          # Entidades JPA
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ repository/     # Repositorios
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ security/       # JWT Security
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ service/        # L√≥gica de negocio
‚îÇ   ‚îî‚îÄ‚îÄ src/main/resources/
‚îÇ       ‚îú‚îÄ‚îÄ application.yml
‚îÇ       ‚îî‚îÄ‚îÄ data/               # Datos legacy CSV
‚îú‚îÄ‚îÄ customer-service/           # Microservicio de clientes
‚îÇ   ‚îú‚îÄ‚îÄ src/main/java/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ com/duoc/bank/customer/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ controller/     # REST Controllers
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ model/          # Entidad Customer
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ repository/     # CustomerRepository
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ security/       # JWT Security
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ service/        # CustomerService
‚îÇ   ‚îî‚îÄ‚îÄ src/main/resources/
‚îÇ       ‚îî‚îÄ‚îÄ application.yml
‚îú‚îÄ‚îÄ transaction-service/        # Microservicio de transacciones
‚îÇ   ‚îú‚îÄ‚îÄ src/main/java/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ com/duoc/bank/transaction/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ controller/     # REST Controllers
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ model/          # Entidad Transaction
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ repository/     # TransactionRepository
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ security/       # JWT Security
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ service/        # TransactionService
‚îÇ   ‚îî‚îÄ‚îÄ src/main/resources/
‚îÇ       ‚îî‚îÄ‚îÄ application.yml
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ pom.xml
‚îú‚îÄ‚îÄ LICENSE
‚îî‚îÄ‚îÄ README.md
```

---

## üìù Patrones Implementados

- ‚úÖ Configuraci√≥n Centralizada (Spring Cloud Config)
- ‚úÖ Service Discovery (Netflix Eureka)
- ‚úÖ Circuit Breaker (Resilience4j)
- ‚úÖ Retry Pattern (Resilience4j)
- ‚úÖ Rate Limiting (Resilience4j)
- ‚úÖ Time Limiter (Resilience4j)
- ‚úÖ Authentication & Authorization (Spring Security + JWT)
- ‚úÖ API Gateway Pattern (Routing centralizado)

---

## üöÄ Despliegue en Producci√≥n

### Variables de Entorno

**Config Server**:

```bash
SPRING_PROFILES_ACTIVE=prod
CONFIG_GIT_URI=https://github.com/your-org/config-repo.git
CONFIG_GIT_USERNAME=your-username
CONFIG_GIT_PASSWORD=your-token
```

**Eureka Server**:

```bash
SPRING_PROFILES_ACTIVE=prod
EUREKA_INSTANCE_HOSTNAME=eureka-prod.yourdomain.com
EUREKA_CLIENT_REGISTER_WITH_EUREKA=false
```

**Account Service**:

```bash
SPRING_PROFILES_ACTIVE=prod
SPRING_DATASOURCE_URL=jdbc:postgresql://prod-db.yourdomain.com:5432/bankdb
SPRING_DATASOURCE_USERNAME=${DB_USERNAME}
SPRING_DATASOURCE_PASSWORD=${DB_PASSWORD}
JWT_SECRET=${JWT_SECRET_KEY}
EUREKA_CLIENT_SERVICE_URL_DEFAULTZONE=http://eureka-prod.yourdomain.com:8761/eureka/
```

**Customer Service**:

```bash
SPRING_PROFILES_ACTIVE=prod
SPRING_DATASOURCE_URL=jdbc:postgresql://prod-db.yourdomain.com:5432/customerdb
SPRING_DATASOURCE_USERNAME=${DB_USERNAME}
SPRING_DATASOURCE_PASSWORD=${DB_PASSWORD}
JWT_SECRET=${JWT_SECRET_KEY}
EUREKA_CLIENT_SERVICE_URL_DEFAULTZONE=http://eureka-prod.yourdomain.com:8761/eureka/
```

**Transaction Service**:

```bash
SPRING_PROFILES_ACTIVE=prod
SPRING_DATASOURCE_URL=jdbc:postgresql://prod-db.yourdomain.com:5432/transactiondb
SPRING_DATASOURCE_USERNAME=${DB_USERNAME}
SPRING_DATASOURCE_PASSWORD=${DB_PASSWORD}
JWT_SECRET=${JWT_SECRET_KEY}
EUREKA_CLIENT_SERVICE_URL_DEFAULTZONE=http://eureka-prod.yourdomain.com:8761/eureka/
```

### Checklist Pre-Producci√≥n

**Seguridad**:

- [ ] Cambiar credenciales por defecto (admin/admin123)
- [ ] Configurar JWT secret fuerte (m√≠nimo 256 bits)
- [ ] Habilitar HTTPS/TLS en todos los servicios
- [ ] Configurar CORS apropiadamente
- [ ] Revisar roles y permisos de usuarios
- [ ] Implementar rate limiting agresivo

**Base de Datos**:

- [ ] Backups autom√°ticos configurados
- [ ] √çndices en columnas de b√∫squeda frecuente
- [ ] Pools de conexiones optimizados
- [ ] Logging de queries lentas activado

**Configuraci√≥n**:

- [ ] Profiles de producci√≥n activados
- [ ] Timeouts configurados apropiadamente
- [ ] Circuit breaker thresholds ajustados
- [ ] Retry strategies validadas

**Monitoreo**:

- [ ] Actuator endpoints asegurados
- [ ] APM configurado (New Relic, Datadog, etc.)
- [ ] Logging centralizado (ELK, Splunk)
- [ ] Alertas configuradas (PagerDuty, Slack)

**Infraestructura**:

- [ ] Auto-scaling configurado
- [ ] Load balancers en lugar
- [ ] Health checks configurados
- [ ] Disaster recovery plan documentado

### Docker en Producci√≥n

**Optimizaci√≥n de Im√°genes**:

```dockerfile
# Multi-stage build para reducir tama√±o
FROM eclipse-temurin:21-jdk-alpine AS builder
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn clean package -DskipTests

FROM eclipse-temurin:21-jre-alpine
WORKDIR /app
COPY --from=builder /app/target/*.jar app.jar
EXPOSE 8081
ENTRYPOINT ["java", "-Xmx512m", "-Xms256m", "-jar", "app.jar"]
```

**Docker Compose Production**:

```yaml
services:
  account-service:
    image: registry.yourdomain.com/account-service:1.0.0
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - JAVA_OPTS=-Xmx1g -Xms512m
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: "1"
          memory: 1G
        reservations:
          cpus: "0.5"
          memory: 512M
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8081/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

### Escalado Horizontal

**Docker Compose Scale**:

```bash
# Escalar Account Service a 3 instancias
docker-compose up -d --scale account-service=3

# Escalar Customer Service a 2 instancias
docker-compose up -d --scale customer-service=2

# Escalar Transaction Service a 3 instancias
docker-compose up -d --scale transaction-service=3

# Escalar todos los servicios
docker-compose up -d --scale account-service=3 --scale customer-service=2 --scale transaction-service=3
```

**Kubernetes (futuro)**:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: account-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: account-service
  template:
    metadata:
      labels:
        app: account-service
    spec:
      containers:
        - name: account-service
          image: account-service:1.0.0
          resources:
            requests:
              memory: "512Mi"
              cpu: "500m"
            limits:
              memory: "1Gi"
              cpu: "1000m"
```

---

## ü§ù Contribuciones

Las contribuciones son bienvenidas. Por favor:

1. Fork el proyecto
2. Crea una rama para tu feature (`git checkout -b feature/AmazingFeature`)
3. Commit tus cambios (`git commit -m 'Add some AmazingFeature'`)
4. Push a la rama (`git push origin feature/AmazingFeature`)
5. Abre un Pull Request

---

## üìß Contacto

**Rodrigo Sanchez**

- Email: [rodrigo@sanchezdev.com](mailto:rodrigo@sanchezdev.com)
- Website: [sanchezdev.com](https://sanchezdev.com)
- GitHub: [@RodrigoSanchezDev](https://github.com/RodrigoSanchezDev)

---

## üìÑ Licencia

Este proyecto est√° licenciado bajo la Licencia MIT - ver el archivo [LICENSE](LICENSE) para m√°s detalles.

---

<div align="center">

**Desarrollado por [Rodrigo Sanchez](https://sanchezdev.com)**

Copyright ¬© 2025 Rodrigo Sanchez. Todos los derechos reservados.

</div>
